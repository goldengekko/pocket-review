package com.wadpam.rnr.dao;

import com.google.appengine.api.datastore.*;
import com.google.appengine.api.datastore.Cursor;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.search.*;
import com.google.appengine.api.search.Index;
import com.wadpam.rnr.domain.DProduct;

import java.util.ArrayList;
import java.util.Collection;
import net.sf.mardao.api.dao.Expression;

/**
 * Implementation of Business Methods related to entity DProduct.
 * This (empty) class is generated by mardao, but edited by developers.
 * It is not overwritten by the generator once it exists.
 *
 * Generated on 2012-08-05T20:54:54.772+0700.
 * @author mardao DAO generator (net.sf.mardao.plugin.ProcessDomainMojo)
 */
public class DProductDaoBean 
	extends GeneratedDProductDaoImpl
		implements DProductDao 
{

    private static final String LOCATION_INDEX = "locationIndex";


    // Find most liked products
    @Override
    public Collection<DProduct> findMostLiked(int limit) {
        return findBy(COLUMN_NAME_LIKECOUNT, false, limit, 0);
    }

    // Find most thumbs up products
    @Override
    public Collection<DProduct> findMostThumbsUp(int limit) {
        return findBy(COLUMN_NAME_THUMBSUP, false, limit, 0);
    }

    // Find most thumbs up products
    @Override
    public Collection<DProduct> findMostThumbsDown(int limit) {
        return findBy(COLUMN_NAME_THUMBSDOWN, false, limit, 0);
    }

    // Find most commented products
    @Override
    public Collection<DProduct> findMostCommented(int limit) {
        return findBy(COLUMN_NAME_COMMENTCOUNT, false, limit, 0);
    }

    // Find most rated products
    @Override
    public Collection<DProduct> findMostRated(int limit) {
        return findBy(COLUMN_NAME_RATINGCOUNT, false, limit, 0);
    }

    // Find products with highest average rating
    @Override
    public Collection<DProduct> findTopRated(int limit) {
        return findBy(COLUMN_NAME_RATINGAVERAGE, false, limit, 0);
    }

    // Get a page of products using pagination
    // TODO: This method should be generated by Mardao and be supported by most methods
    @Override
    public String getProductPage(String cursor, int pageSize, Collection<DProduct> result) {

        DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
        Query query = new Query("DProduct");
        PreparedQuery preparedQuery = datastore.prepare(query);

        // Set fetch options
        FetchOptions fetchOptions = FetchOptions.Builder.withLimit(pageSize);
        if (null != cursor)
            fetchOptions.startCursor(Cursor.fromWebSafeString(cursor));

        // Run the query
        QueryResultList<Entity> entities = preparedQuery.asQueryResultList(fetchOptions);

        // Build the DProduct domain object from the entities
        for (Entity entity : entities) {
            DProduct dProduct = new DProduct();

            LOG.debug("Entity key name: " + entity.getKey().getName());
            dProduct.setProductId( entity.getKey().getName());
            dProduct.setRatingSum((Long)entity.getProperty("ratingSum"));
            dProduct.setRatingCount((Long)entity.getProperty("ratingCount"));
            dProduct.setRatingAverage((Rating)entity.getProperty("ratingAverage"));
            dProduct.setLikeCount((Long)entity.getProperty("likeCount"));
            dProduct.setCommentCount((Long)entity.getProperty("commentCount"));
            dProduct.setLocation((GeoPt) entity.getProperty("location"));

            result.add(dProduct);
        }

        // Get a new cursor
        String newCursor = entities.getCursor().toWebSafeString();

        return newCursor;
    }

    // Persist and index a product based in location (needed for location based search)
    @Override
    public String persistAndIndexLocation(DProduct dProduct) {

        // Index the geo location
        if (null != dProduct.getLocation()) {
            GeoPoint geoPoint = new GeoPoint(dProduct.getLocation().getLatitude(), dProduct.getLocation().getLongitude());
            Document.Builder locationBuilder = Document.newBuilder()
                    .setId(dProduct.getProductId())
                    .addField(Field.newBuilder().setName("location").setGeoPoint(geoPoint))
                    .addField(Field.newBuilder().setName("averageRating").setNumber(dProduct.getRatingAverage().getRating()))
                    .addField(Field.newBuilder().setName("linkCount").setNumber(dProduct.getLikeCount()));
            getLocationIndex().add(locationBuilder.build());
        }

        return this.persist(dProduct);
    }

    // Build location index
    private com.google.appengine.api.search.Index getLocationIndex() {
        IndexSpec indexSpec = IndexSpec.newBuilder()
                .setName(LOCATION_INDEX)
                .setConsistency(Consistency.PER_DOCUMENT)
                .build();
        return SearchServiceFactory.getSearchService().getIndex(indexSpec);
    }

    // Search for nearby places
    @Override
    public String searchInIndexForNearby(String cursor, int pageSize, Float latitude, Float longitude,
                                         int radius, SortOrder sortOrder, Collection<DProduct> result) {

        // Build the query string
        String queryString = String.format("distance(location, geopoint(%f, %f)) < %d", latitude, longitude, radius);

        // Sort expression
        SortExpression sortExpression = null;
        switch (sortOrder) {
            case DISTANCE:
                String sortString = String.format("distance(location, geopoint(%f, %f))", latitude, longitude);
                sortExpression = SortExpression.newBuilder()
                        .setExpression(sortString)
                        .setDirection(SortExpression.SortDirection.ASCENDING)
                        .setDefaultValueNumeric(radius + 1)
                        .build();
                break;
            case TOP_RATED:
                sortExpression = SortExpression.newBuilder()
                        .setExpression("averageRating")
                        .setDirection(SortExpression.SortDirection.DESCENDING)
                        .setDefaultValue("")
                        .build();
                break;
            case MOST_LIKED:
                sortExpression = SortExpression.newBuilder()
                        .setExpression("linkCount")
                        .setDirection(SortExpression.SortDirection.DESCENDING)
                        .setDefaultValue("")
                        .build();
                break;
        }

        // Options
        QueryOptions options = null;
        QueryOptions.Builder builder = QueryOptions.newBuilder()
                .setSortOptions(SortOptions.newBuilder().addSortExpression(sortExpression))
                .setLimit(pageSize);

        if (null != cursor)
            builder.setCursor(com.google.appengine.api.search.Cursor.newBuilder().build(cursor));

        // Build query
        com.google.appengine.api.search.Query query = com.google.appengine.api.search.Query.newBuilder()
                .setOptions(options)
                .build(queryString);

        return searchInIndexWithQuery(query, getLocationIndex(), result);
    }

    // Search in index for a query
    private String searchInIndexWithQuery(com.google.appengine.api.search.Query query, Index index, Collection<DProduct> result) {

        try {
            // Query the index.
            Results<ScoredDocument> results = index.search(query);

            // Collect all the primary keys
            Collection<String> ids = new ArrayList<String>();
            for (ScoredDocument document : results) {
                ids.add(document.getId());
            }

            if (ids.size() != 0) {
                // We got results, get the places from datastore
                result = this.findByPrimaryKeys(ids).values();
                return results.getCursor().toWebSafeString();
            } else {
                // No results, return empty list
                result = new ArrayList<DProduct>(0);
                return null;
            }
        } catch (SearchException e) {
            if (StatusCode.TRANSIENT_ERROR.equals(e.getOperationResult().getCode())) {
                LOG.error("Search index failed");
                // TODO: Error handling missing
            }
            throw new SearchException("Searching index failed");
        }
    }

}
